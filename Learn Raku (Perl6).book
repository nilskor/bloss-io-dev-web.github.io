raku --help

/usr/lib/perl6/runtime/perl6.moarvm [switches] [--] [programfile] [arguments]

With no arguments, enters a REPL (see --repl-mode option).
With a "[programfile]" or the "-e" option, compiles the given program
and, by default, also executes the compiled code.

  -c                   check syntax only (runs BEGIN and CHECK blocks)
  --doc                extract documentation and print it as text
  -e program           one line of program, strict is enabled by default
  -h, --help           display this help text
  -n                   run program once for each line of input
  -p                   same as -n, but also print $_ at the end of lines
  -I path              adds the path to the module search path
  -M module            loads the module prior to running the program
  --target=stage       specify compilation stage to emit
  --optimize=level     use the given level of optimization (0..3)
  -o, --output=name    specify name of output file
  -v, --version        display version information
  -V                   print configuration summary
  --stagestats         display time spent in the compilation stages
  --ll-exception       display a low level backtrace on errors
  --profile[=kind]     write profile information to an HTML file (MoarVM)
                         [kind=] instrumented - performance measurements (default)
                         [kind=] heap - record heap snapshots after every garbage collector run
  --profile-compile[=kind]
                       write compile-time profile information to an HTML file (MoarVM)
                         instrumented - performance measurements (default)
                         heap - record heap snapshots after every garbage collector run
  --profile-filename=name
                       provide a different filename for profile.
                       Extension controls format:
                         .json outputs in JSON
                         .sql  outputs in SQL
                         any other extension outputs in HTML
  --profile-stage=stage
                       write profile information for the given compilation stage to an HTML file (MoarVM)
  --doc=module         use Pod::To::[module] to render inline documentation

  --repl-mode=interactive|non-interactive
                       when running without "-e" or filename arguments,
                       a REPL is started. By default, if STDIN is a TTY,
                       "interactive" REPL is started that shows extra messages and
                       prompts, otherwise a "non-interactive" mode is used where
                       STDIN is read entirely and evaluated as if it were a program,
                       without any extra output (in fact, no REPL machinery is even
                       loaded). This option allows to bypass TTY detection and
                       force one of the REPL modes.

Note that only boolean single-letter options may be bundled.

To modify the include path, you can set the PERL6LIB environment variable:

    PERL6LIB="lib" perl6 example.pl


---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------


Variable declarators and scope

    'use strict;' is the default behavior, and requires that you declare variables before using them.
    You can relax this restriction with 'no'.

    no strict; $x = 42;     # Ok


    Most of the time it's enough to create a new variable using the 'my' keyword:

        my $amazing-variable = "World";
        say "Hello $amazing-variable!";     # OUTPUTS: Hello World!

    If no type is provided by the user Raku assumes the type to be 'Any'. 
    This includes variables (otherwise known as 'containers' in 
    Perl6/Raku speak), base-classes, parameters and return types.

    Declarator 	Effect
    ==================
    my 	        Introduces lexically scoped names
    our 	    Introduces package-scoped names
    has 	    Introduces attribute names
    anon 	    Introduces names that are private to the construct
    state 	    Introduces lexically scoped but persistent names
    augment 	Adds definitions to an existing name
    supersede 	Replaces definitions of an existing name
    constant 	Declares that a variable value is not going to change during its lifetime

    Two declarators are reserved for acting on predefined variables:

    Declarator  Effect
    ==================
    temp 	    Restores a variable's value at the end of scope
    let 	    Restores a variable's value at the end of scope if the block exits unsuccessfully


Variables with Type

    Simple types:

    bool - boolean
    int  - integer 64-bit
    uint - unsigned integer 64-bit
    num  - floating point 64-bit
    str  - string
    void - void

    Examples:

        my int $type = 3;       # declares an Integer variable called type
        say $type;              # print the value '3'
        say $type.^name;        # OUTPUTS: Int
        say $type.WHAT;         # OUTPUTS: (Int)


    Additionally, use the keyword 'is' to assign a Type to a variable.

    class SomeHashClass is Hash { /* code */ }

    my %hashVariable is SomeHashClass = oranges => "round", bananas => "bendy";


Variable Prefixes (Sigils)

    All variables are marked with leading sigils, which allow variables to be interpolated directly
    into strings. However, unlike the shell, Perl uses sigils on all accesses to variables, and 
    unlike most other programming languages that use sigils, the sigil doesn't denote the type of
    the variable but the type of the expression. So for example, to access a list of values in a 
    hash, the sigil for an array ("@") is used, not the sigil for a hash ("%").

    There are four sigils.

    The scalar-sigil $, the positional-sigil @, the associative-sigil % and the callable-sigil &.
    
    The convention for Raku is to use Sigils, although it is possible to have variables without.

        $ is typically for an item, defaults to 'Any' type
        @ is typically for arrays, lists ranges etc., defaults to 'Array' type
        % is typically for hashes or maps, defaults to 'Hash' type
        & is typically for a Function, Method, Sub-routine, default to 'Callable' type

    Examples:

        my $square = 9 ** 2;
        my @array  = 1, 2, 3;                                # Array variable with three elements 
        my %hash   = London => 'UK', Berlin => 'Germany';


Secondary Variable Prefixes (Twigils)

    Twigils can only influence the scoping of a variable. There are 10 recognised Twigils:

        ! 	    Attribute (class member)
        * 	    Dynamic
        . 	    Method (not really a variable)
        : 	    Self-declared formal named parameter
        < 	    Index into match object (not really a variable)
        = 	    Pod variables
        ? 	    Compile-time variable
        ^ 	    Self-declared formal positional parameter
        none 	Based only on declarator
        ~ 	    The sublanguage seen by the parser at this lexical spot

    Examples:

        Attributes are variables that exist per instance of a class. They 
        may be directly accessed from within the class via !
        
        my class Point
        {
            has $.x;
            has $.y;
    
            method Str()
            {
                "($!x, $!y)"
            }
        }

        Note how the attributes are declared as $.x and $.y but are still 
        accessed via $!x and $!y. This is because in Raku all attributes 
        are private and can be directly accessed within the class by using
        $! attribute-name. Raku may automatically generate accessor methods 
        for you though.

        The . twigil isn't really for variables at all. In fact, something
        along the lines of:

        my class Point
        {
            has $.x;
            has $.y;
 
            method Str()
            {
                "($.x, $.y)"    # note that we use the . instead of ! this time 
            }
        }

        This just calls the methods x and y on self, which are automatically
        generated for you because you used the . twigil when the attributes 
        were declared. Note, however, that subclasses may override those 
        methods. If you don't want this to happen, use $!x and $!y instead.

        The fact that the . twigil does a method call implies that the 
        following is also possible:

        class SaySomething
        {
            method a() { say "a"; }
            method b() { $.a; }
        }
 
        SaySomething.b;     # OUTPUTS: a


Special Variables

    There are lexical, dynamic and environment variables that are availalble in Raku. These are typically
    written in uppercase and follow the form: $*SOME-NAME, with the exception being the lexical variables, 
    which are seen as $_ , $/ , $! and more.

Anonymous Variables

    Using $ , @ or % by itself will behave as an anonymous variable.

    Example - printing lines of a file, numbering each line:

        raku -ne 'say ++$ ~ " $_"' example.txt

        Not only is an anonymous vatiable used ( ++$ ) but also the special inbuilt lexical variable $_ ,
        which is the 'topic' variable.

        for <a b c> { say $_ }              # sets $_ to 'a', 'b' and 'c' in turn 
        raku -ne 'say $_' example.txt       # print every line of the file example.txt

Coercion

    my $whatever = "123.6";
    say $whatever.round;        # OUTPUTS:  124


---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------


Regexes

    Perl was originally developed as a general-purpose Unix scripting language to make report processing easier.
    It borrows features from other programming languages including C, shell script (sh), AWK, and sed.
    Perl/Perl6/Raku provide text processing facilities without the arbitrary data-length limits of many 
    contemporary Unix command line tools, facilitating manipulation of text files. Perl 5 gained widespread
    popularity in the late 1990s as a CGI scripting language, in part due to its unsurpassed regular expression
    and string parsing abilities.

    A regular expression is a sequence of characters that defines a certain text pattern, typically one that 
    one wishes to find in some large body of text.

    In Raku, regexes are written in a domain-specific language, i.e. a sublanguage or slang.

Lexical conventions

    Fundamentally, Raku regexes are very much like subroutines: both are code objects, and just as you can
    have anonymous subs and named subs, you can have anonymous and named regexes.

    A regex, whether anonymous or named, is represented by a Regex object. Yet, the syntax for constructing
    anonymous and named Regex objects differs.

Anonymous regex definition syntax.

    An anonymous regex may be constructed in one of the following ways:

        rx/pattern/;          # an anonymous Regex object; 'rx' stands for 'regex' 
        /pattern/;            # an anonymous Regex object; shorthand for 'rx/.../' 
 
        regex { pattern };    # keyword-declared anonymous regex; this form is 
                              # intended for defining named regexes and is discussed 
                              # in that context in the next section


    The rx/ / form has two advantages over the bare shorthand form / /.

    Firstly, it enables the use of delimiters other than the slash, which may be used to improve the 
    readability of the regex definition:

        rx{ '/tmp/'.* };      # the use of curly braces as delimiters makes this first 
        rx/ '/tmp/'.* /;      # definition somewhat easier on the eyes than the second

    Although the choice is vast, not every character may be chosen as an alternative regex delimiter.

    Secondly, the rx form enables the use of regex adverbs, which may be placed between rx and the 
    opening delimiter to modify the definition of the entire regex:

        rx:r:s/pattern/;            # :r (:ratchet) and :s (:sigspace) adverbs, defining 
                                    # a ratcheting regex in which whitespace is significant

    Although anonymous regexes are not, as such, named, they may effectively be given a name by 
    putting them inside a named variable, after which they can be referenced, both outside of an 
    embedding regex and from within an embedding regex by means of interpolation:

        my $regex = / R \w+ /;
        say "Zen Buddhists like Raku too" ~~ $regex;    # OUTPUTS: Raku 
 
        my $regex = /pottery/;
        "Japanese pottery rocks!" ~~ / <$regex> /;      # Interpolation of $regex into /.../ 
        say $/;                                         # OUTPUTS: pottery
    

Named regex definition syntax.

    A named regex may be constructed using the regex declarator as follows:

        regex R { pattern };        # a named Regex object, named 'R'

    Unlike with the rx form, you cannot chose your preferred delimiter: curly braces are mandatory.
    In this regard it should be noted that the definition of a named regex using the regex form is 
    syntactically similar to the definition of a subroutine:

        my sub   S { /pattern/ };   # definition of Sub object (returning a Regex) 
        my regex R {  pattern  };   # definition of Regex object

    which emphasizes the fact that a Regex object represents code rather than data:

        &S ~~ Code;                 # OUTPUTS: True 
    
        &R ~~ Code;                 # OUTPUTS: True 
        &R ~~ Method;               # OUTPUTS: True (A Regex is really a Method!) 

    Also unlike with the rx form for defining an anonymous regex, the definition of a named 
    regex using the regex keyword does not allow for adverbs to be inserted before the opening 
    delimiter. Instead, adverbs that are to modify the entire regex pattern may be included 
    first thing within the curly braces:

        regex R { :i pattern };     # :i (:ignorecase), renders pattern case insensitive

    Alternatively, by way of shorthand, it is also possible (and recommended) to use the rule 
    and token variants of the regex declarator for defining a Regex when the :ratchet and 
    :sigspace adverbs are of interest:

        regex R { :r pattern };     # apply :r (:ratchet) to entire pattern 

    and, alternatively

        token R { pattern };        # same thing: 'token' implies ':r' 

    Or

        regex R { :r :s pattern };  # apply :r (:ratchet) and :s (:sigspace) to pattern 

    with this alternative:

        rule  R { pattern };        # same thing: 'rule' implies ':r:s' 

    Named regexes may be used as building blocks for other regexes, as they are methods that 
    may called from within other regexes using the <regex-name> syntax. When they are used 
    this way, they are often referred to as subrules. Grammars are the natural habitat of 
    subrules, but many common predefined character classes are also implemented as named regexes.

    Regex readability: whitespace and comments

    Whitespace in regexes is ignored unless the :sigspace adverb is used to make whitespace 
    syntactically significant.

    In addition to whitespace, comments may be used inside of regexes to improve their 
    comprehensibility just as in code in general. This is true for both single line comments 
    and multi line/embedded comments:

        my $regex =  rx/ \d ** 4            # (match the year YYYY) 
                         '-'
                         \d ** 2            # ...the month MM 
                         '-'
                         \d ** 2 /;         # ...and the day DD 
    
        say '2015-12-25'.match($regex);     # OUTPUTS: 2015-12-25


Match syntax

    There are a variety of ways to match a string against a regex. Irrespective of the syntax 
    chosen, a successful match results in a Match object. In case the match is unsuccessful, 
    the result is Nil. In either case, the result of the match operation is available via the 
    special match variable $/.

    The most common ways to match a string against an anonymous regex /pattern/ or against a 
    named regex R include the following:


    - Smartmatch: "string" ~~ /pattern/, or "string" ~~ /<R>/

    Smartmatching a string against a Regex performs a regex match of the string against the Regex:

        say "Go ahead, make my day." ~~ / \w+ /;   # OUTPUTS: Go 
     
        my regex R { me|you };
        say "You talkin' to me?" ~~ / <R> /;       # OUTPUTS: me   R => me 
        say "May the force be with you." ~~ &R ;   # OUTPUTS: you

    The different outputs of the last two statements show that these two ways of smartmatching 
    against a named regex are not identical. The difference arises because the method call <R> 
    from within the anonymous regex / / installs a so-called 'named capture' in the Match object, 
    while the smartmatch against the named Regex as such does not.


    - Explicit topic match: m/pattern/, or m/<R>/

    The match operator m/ / immediately matches the topic variable $_ against the regex following the m.

    As with the rx/ / syntax for regex definitions, the match operator may be used with adverbs 
    in between m and the opening regex delimiter, and with delimiters other than the slash. However, 
    while the rx/ / syntax may only be used with regex adverbs that affect the compilation of the 
    regex, the m/ / syntax may additionally be used with matching adverbs that determine how the 
    regex engine is to perform pattern matching.

    Here's an example that illustrates the primary difference between the m/ / and / / syntax:

        my $match;
        $_ = "abc";
        
        $match = m/.+/;
        say $match; say $match.^name;   # OUTPUTS: abc    Match

        $match =  /.+/;
        say $match; say $match.^name;   # OUTPUTS: /.+/   Regex


    - Implicit topic match in sink and boolean contexts

    In case a Regex object is used in sink context, or in a context in which it is coerced to Bool,
    the topic variable $_ is automatically matched against it:

        $_ = "dummy string";        # Set the topic explicitly 
     
        rx/ s.* /;                  # Regex object in sink context matches automatically 
        say $/;                     # OUTPUTS: string 
     
        say $/ if rx/ d.* /;        # Regex object in boolean context matches automatically 
                                    # OUTPUTS: dummy string


    - Match method: "string".match: /pattern/, or "string".match: /<R>/

    The match method is analogous to the m/ / operator discussed above. Invoking it on a string, 
    with a Regex as an argument, matches the string against the Regex.


    - Parsing grammars: grammar-name.parse($string)

    Although parsing a Grammar involves more than just matching a string against a regex, 
    this powerful regex-based text destructuring tool can't be left out from this overview of 
    common pattern matching methods.

Literals and metacharacters

    A regex describes a pattern to be matched in terms of literals and metacharacters. 
    Alphanumeric characters and the underscore _ constitute the literals: these characters match 
    themselves and nothing else. Other characters act as metacharacters and may, as such, have 
    a special meaning, either by themselves (such as the dot ., which serves as a wildcard) or 
    together with other characters in larger metasyntactic constructs (such as <?before ...>, 
    which defines a lookahead assertion).

    In its simplest form a regex comprises only literals:

        /Cześć/;           # "Hello" in Polish 
        /こんばんは/;        # "Good afternoon" in Japanese 
        /Καλησπέρα/;       # "Good evening" in Greek

    If you want a regex to literally match one or more characters that normally act as 
    metacharacters, those characters must either be escaped using a backslash, or be quoted 
    using single or double quotes.

    The backslash serves as a switch. It switches a single metacharacter into a literal, 
    and vice versa:

        / \# /;             # matches the hash metacharacter literally 
        / \w /;             # turns literal 'w' into a character class (see below) 
        /Hallelujah\!/;     # matches string 'Hallelujah!' incl. exclamation mark

    Even if a metacharacter does not (yet) have a special meaning in Raku, escaping 
    (or quoting) it is required to ensure that the regex compiles and matches the character 
    literally. This allows the clear distinction between literals and metacharacters to be 
    maintained. So, for instance, to match a comma this will work:

        / \, /;             # matches a literal comma ','

    while this will fail:

        / ,  /;             # !! error: an as-yet meaningless/unrecognized metacharacter 
                            # does not automatically match literally 

    While an escaping backslash exerts its effect on the next individual character, 
    both a single metacharacter and a sequence of metacharacters may be turned into 
    literally matching strings by quoting them in single or double quotes:

        / "abc" /;          # quoting literals does not make them more literal 
        / "Hallelujah!" /;  # yet, this form is generally preferred over /Hallelujah\!/ 
        
        / "two words" /;    # quoting a space renders it significant, so this matches 
                            # the string 'two words' including the intermediate space 
        
        / '#!:@' /;         # this regex matches the string of metacharacters '#!:@'

    Quoting does not simply turn every metacharacter into a literal, however. This is 
    because quotes allow for backslash-escapes and interpolation. Specifically: in single 
    quotes, the backslash may be used to escape single quotes and the backslash itself; 
    double quotes additionally enable the interpolation of variables, and of code blocks 
    of the form {...}. Hence all of this works:

        / '\\\'' /;          # matches a backslash followed by a single quote: \' 
        
        my $x = 'Hi';
        / "$x there!" /;     # matches the string 'Hi there!' 
        
        / "1 + 1 = {1+1}" /; # matches the string '1 + 1 = 2'

    while these examples illustrate mistakes that you will want to avoid:

        / '\' /;                # !! error: this is NOT the way to literally match a 
                                # backslash because now it escapes the second quote 
    
        /"Price tag $0.50"/;    # !! error: "$0" is interpreted as the first positional 
                                # capture (which is Nil), not as '$0' 

    Strings are searched left to right, so it is enough if only part of the string matches
    the regex:

    if 'Life, the Universe and Everything' ~~ / and / 
    {
        say ~$/;            # OUTPUTS: and
        say $/.prematch;    # OUTPUTS: Life, the Universe
        say $/.postmatch;   # OUTPUTS: Everything 
        say $/.from;        # OUTPUTS: 19 
        say $/.to;          # OUTPUTS: 22 
    };

    Match results are always stored in the $/ variable and are also returned from the 
    match. They are both of type Match if the match was successful; otherwise both 
    are of type Nil.