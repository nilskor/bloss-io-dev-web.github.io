#!/bin/bash

# Will exit script if we would use an uninitialised variable:
# either set -u or set -o nounset
set -o nounset

# Will exit script when a simple command (not a control structure) fails:
# either set -e or set -o errexit
set -o errexit

# This setting prevents errors in a pipeline from being masked.
set -o pipefail

#set -vx

# Useful string splitting behaviour occurs with IFS=$'\n\t'
# The default is to split on spaces, tabs and newlines $' \n\t'
IFS=$'\n\t'

# Set variables:
declare -ri  TRUE=0             # g - global scope; r - read-only; i - integer; x - exportable
declare -ri FALSE=1

declare RED='\033[1;31m'        # actually a light Red to be exact :)
declare GREEN='\033[0;32m'
declare NC='\033[0m'            # No Color

declare -a  theArgs=()          # a - indexed array
declare -a htmlLines=()


#----------------------------------------------------------
# Overridden Echo function - www.etalabs.net/sh_tricks.html
#----------------------------------------------------------
#
function echo()
{
    fmt=%s end=\\n IFS=" "

    while [ $# -gt 1 ]
    do
        case "$1" in

            [!-]*|-*[!ne]*) break ;;

            *ne*|*en*) fmt=%b end= ;;

            *n*) end= ;;

            *e*) fmt=%b ;;

        esac
        shift
    done

    printf "$fmt$end" "$*"
    setIFS
}

function usage()
(
    echo -e ""
    echo -e "usage goes here"
    echo -e "All Here Document, Here-doc or Heredoc style input must end with a plain 'EOF' eg. EOF"
    echo -e ""
)

function    setIFS(){ IFS=$'\n\t'; }
function  unsetIFS(){ IFS= ;       }

#----------------------------------------------------------
# Read Here-Docs either directly or forced with '-hd'
#----------------------------------------------------------
#
function readInput()                # bash
{
    setIFS
    while read -r line
    do
        if [[ $line == "EOF" ]]
        then
            break
        fi
        htmlLines+=($line$'\n')    # Push  # new-line is :   $'\n'
    done
}

function _countLines()              # bash wc gawk
{
    # <SIGNATURE>: (0)_countLines (1)_result (2)someStringToSearch
    # <RETURN>   : (0)<T>Integer
    # <OPTIONS>  : (0) -hd
    # <BACKEND>  : bash, wc, gawk

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    local -i _return_countLines

    if [[ $# -eq 1 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
    then
        #echo "${#htmlLines[@]}"
        _return_countLines="${#htmlLines[@]}"
        eval "$1=\${_return_countLines}"

    elif [[ $# -eq 1 || $2 == "-?" || $2 == "--help" || $2 == "-h" || -z $2 ]]
    then

        echo -e "\n countLines inputFileName <or> \"some string\" <or> <<Here-document ending with EOF\n"

    elif [[ -f $2  ]]
    then

        declare -i result="$(wc --lines $2 | gawk {'print $1'})" # gawk print $1 shouldn't be changed ..
        #if [[ $result -gt 1 ]]
        #then
        #        result=$((++result))
        #fi
        #echo "$result"
        returnResult="$result"
        eval "$1=\${returnResult}"

    else

        #echo -e "Just about to count lines .. $2"
        #declare -i result="$(wc --lines <<< $2)"
        declare -i result=$(wc --lines <<< "${2}")
        #echo -e "Just did the count and found $result lines in $2."
        #if [[ $result -gt 1 ]]
        #then
        #        result=$((++result))
        #fi

        #echo -e "Number of elements in htmlLines is: ${#htmlLines[@]}, ${htmlLines[@]}"
        #echo "here"
        if [[ ${#htmlLines[@]} -gt 0 ]]
        then
            result+=${#htmlLines[@]}

        fi

        #echo "$result"

        printf -v _return_countLines %q $result
        #_return_countLines="freddo frog"
        eval "$1=\${_return_countLines}"

    fi

}

function _countWords()              # bash wc gawk
{
    # <SIGNATURE>: (0)_countWords (1)_result (2)someStringToSearch
    # <RETURN>   : (0)<T>Integer
    # <OPTIONS>  : (0) -hd
    # <BACKEND>  : bash, wc, gawk

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        #echo -e "Individual arg is: $arg, and index is $n"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    local -i _return_countWords
    local -i result=0

    #if [[ $# -eq 0 || -z $1 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
    if [[ $# -eq 1 || -z $2 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
    then

        returnResult="${#htmlLines[@]}"
        eval "$1=\${returnResult}"

    elif [[ $# -eq 1 || $2 == "-?" || $2 == "--help" || $2 == "-h" || -z $2 ]]
    then

        echo -e "\n countWords inputFileName <or> \"some string\" <or> <<Here-document ending with EOF\n"

    elif [[ -f $2  ]]
    then

        result="$(wc --words $2 | gawk {'print $1'})" # gawk print $1 shouldn't be changed ..

        printf -v _return_countWords %q $result
        eval "$1=\${_return_countWords}"

    else

        result=$(wc --words <<< "${2}")

        if [[ ${#htmlLines[@]} -gt 0 ]]
        then
            result+=${#htmlLines[@]}

        fi

        printf -v _return_countWords %q $result
        eval "$1=\${_return_countWords}"

    fi

}

function _stringLength()            # bash                      # alias len
{
    # <SIGNATURE>: (0)_stringLength (1)_result (2)someStringToSearch
    # <RETURN>   : (0)<T>Integer
    # <OPTIONS>  : (0) -hd
    # <BACKEND>  : bash

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local -i _return_stringLength

    declare -i result=0

    if [[ $# -eq 1 || -z $2 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
    then

        returnResult="${#htmlLines[@]}"
        returnResult=$(( returnResult ))
        eval "$1=\${returnResult}"

    elif [[ $# -eq 1 || $2 == "-?" || $2 == "--help" || $2 == "-h" || -z $2 ]]
    then
        echo -e "\n stringLength someString or 'some continuous string that is quoted'\n"

    elif [[ $# -eq 2 ]] && [[ -f $2  ]]
    then
        stringToBeSearched="$(< $2)"
        result="$(( ${#stringToBeSearched} ))"
        printf -v _return_stringLength %q $result
        eval "$1=\${_return_stringLength}"

    else

        result="$(( ${#2} ))"
        printf -v _return_stringLength %q $result
        eval "$1=\${_return_stringLength}"

    fi

}

function _regexStringFind()         # bash grep -P head         # alias inStr
{
    # <SIGNATURE>: (0)_regexStringFind (1)_result (2)searchPattern (3)someStringToSearch (4?)options
    # <RETURN>   : (0)<T>Integer
    # <OPTIONS>  : (0) -hd (1) -s
    # <BACKEND>  : bash, grep -P, head
    # <TEMPLATE> : _regexStringFind _theResult "searchPattern" "someStringToSearch"

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local -i _return_regexStringFind=0
    local -i result=0
    local stringToBeSearched=""
    local -i stringNotPosition=$FALSE

    if [[ $# -le 1 ]]
    then
        echo -e "\n missing arguments"
        echo -e " The command syntax is: regexStringFind searchPattern someStringToSearch"
        echo -e " Regular Expressions are allowed in 'searchPattern'"
        echo -e " regexStringFind returns a number greater than 0 if successful."
        echo -e " regexStringFind assumes the first character occupies position #1\n"
        echo -e " If the switch '-s' is added as the last parameter, then the string is"
        echo -e " returned, rather than the position.\n"

    elif [[ $# -ge 3 ]] || [[ $# -eq 2 && ${#htmlLines[@]} -gt 0 ]]
    then
        
        if [[ $# -ge 3 ]] && [[ -f $3  ]]
        then
                #stringToBeSearched="$(sed -rn 's/.*/&/p' $3)"
                stringToBeSearched="$(< $3)"
        
        elif [[ $# -ge 3 ]]
        then
                stringToBeSearched="${3} ${htmlLines[@]}"
        
        elif [[ $# -eq 2 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
        then
                stringToBeSearched="${htmlLines[@]}"
        fi

        # START - set the booleans for the optionals
        if [[ ! -z ${4:-} ]] && [[ $(_sc regexStringFind '([-][s]{1,}\b)' ${4:-}) -gt 0 ]]
        then
            stringNotPosition=$TRUE
        fi
        # END setting the booleans


        thePattern="$2"

        foundIt=`grep -P -i -o -m 1 "$thePattern" <<< "$stringToBeSearched" | head -n 1` || foundIt=""
    
        if [[ ${#foundIt} -gt 0 ]]
        then
            searchString="$foundIt"
            rest=${stringToBeSearched#*$searchString}
            result="$(( ${#stringToBeSearched} - ${#rest} - ${#searchString} + 1 ))"
        else
            result=0
        fi

        if [[ $stringNotPosition -eq $FALSE ]]
        then
            printf -v _return_regexStringFind %q $result
            eval "$1=\${_return_regexStringFind}"
        else
            eval "$1=\${foundIt}"
        fi

    fi

}

function _regexStringFind2()        # bash grep -P
{
    # <SIGNATURE>: (0)_regexStringFind2 (1)_resultArray (2)searchPattern (3)someStringToSearch
    # <RETURN>   : (0)<T>AADS - Associative Array Definition String; always named 'ArrayOfStrings'
    # <OPTIONS>  : (0) -hd
    # <BACKEND>  : bash, grep -P

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    local -A ArrayOfStrings=()

    # main part of the function

    if [[ $# -le 2 ]]
    then
        echo -e "\n missing arguments.\n"
        echo -e " The command syntax is: regexStringFind2 searchPattern someStringToSearch"
        echo -e " The return result is an Associative array eg. declare -A someVariable"
        echo -e " The return result creates a hard-coded variable name - 'ArrayOfStrings'."

    elif [[ $# -eq 3 ]] || [[ $# -eq 2 && ${#htmlLines[@]} -gt 0 ]]
    then
        
        if [[ $# -eq 3 ]] && [[ -f $3  ]]
        then
                stringToBeSearched="$(< "$3")"
        
        elif [[ $# -eq 3 ]]
        then
                stringToBeSearched="${3} ${htmlLines[@]}"
        
        elif [[ $# -eq 2 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
        then
                stringToBeSearched="${htmlLines[@]}"
        fi

        thePattern="$2"

        #foundIt=`grep -P -i -o -m 1 "$thePattern" <<< "$stringToBeSearched" | head -n 1` || foundIt=""
        foundIt=`grep -P -i -o "$thePattern" <<< "$stringToBeSearched"` || foundIt=""

        if [[ ${#foundIt} -gt 0 ]]
        then
            foundIt=($foundIt)
            #declare -p ArrayOfStrings
            for item in ${foundIt[@]}
            do
                #echo -e "$item"
                #:
                searchString="$item"
                _return_regexStringFind_String="$foundIt"
                rest=${stringToBeSearched#*$searchString}
                result="$(( ${#stringToBeSearched} - ${#rest} - ${#searchString} + 1 ))"
                ArrayOfStrings[$result]="$item"

            done
        fi
        #echo -e "Length of ArrayOfStrings[] is: ${#ArrayOfStrings[@]}"
        if [[ ${#ArrayOfStrings[@]} -gt 0 ]]
        then
            for item in ${!ArrayOfStrings[@]}
            do
                #echo "$item, ${ArrayOfStrings[$item]}"
                :
            done
        fi

        eval "$1=\$(declare -p ArrayOfStrings)"

        #anyRepeats
        
        #if [[ ${#foundIt} -gt 0 ]]
        #then
        #    searchString="$foundIt"
        #    _return_regexStringFind_String="$foundIt"
        #    rest=${stringToBeSearched#*$searchString}
        #    result="$(( ${#stringToBeSearched} - ${#rest} - ${#searchString} + 1 ))"
        #else
        #    result=0
        #fi

        #printf -v _return_regexStringFind_Index %q $result
        #eval "$1=\${_return_regexStringFind_Index}"
        #eval "$2=\${_return_regexStringFind_String}"_resultArray

    fi

}

function _findReplace()             # bash
{
    # <SIGNATURE>: (0)_findReplace (1)_result (2)oldString/pattern (3)newString (4)someStringToSearch
    # <RETURN>   : (0)<T>String
    # <OPTIONS>  : (0) -hd (1) -a or -w or -aw
    # <BACKEND>  : bash

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    #echo -e "@ is: $@, which is equal to $#. htmlLines is ${#htmlLines[@]}."

    local _return_findReplace=""
    local -i doAll=$FALSE
    local -i writeFile=$FALSE

    if [[ $# -ge 4 ]] || [[ $# -eq 3 && ${#htmlLines[@]} -gt 0 ]]
    then
        
        if [[ $# -ge 4 ]] && [[ -f $4  ]]
        then
                #stringToBeSearched="$(sed -rn 's/.*/&/p' $4)"
                stringToBeSearched="$(< $4)"
        
        elif [[ $# -ge 4 ]]
        then
                stringToBeSearched="$4"
        
        elif [[ $# -eq 3 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
        then
                stringToBeSearched="${htmlLines[@]}"
        fi

        if [[ ! -z ${5:-} ]] && [[ ${5:-} == "-a" ]]
        then
            doAll=$TRUE

        elif [[ ! -z ${5:-} ]] && [[ ${5:-} == "-w" ]] && [[ -f $4  ]]
        then
            writeFile=$TRUE

        elif [[ ! -z ${5:-} ]] && [[ ${5:-} == "-aw" ]] && [[ -f $4  ]]
        then
            doAll=$TRUE && writeFile=$TRUE
        fi

        thePattern="${2:-}"
        newString="${3:-}"

        if [[ $doAll == $FALSE ]]
        then
            #echo -e "$stringToBeSearched; $thePattern; $newString;"
            _return_findReplace="${stringToBeSearched/${thePattern}/${newString}}"
        else
            _return_findReplace="${stringToBeSearched//${thePattern}/${newString}}"
        fi

        if [[ $writeFile == $TRUE ]]
        then
            echo "$_return_findReplace">$4
        fi

        eval "$1=\${_return_findReplace}"


    elif [[ $# -eq 1 || $2 == "-?" || $2 == "--help" || $2 == "-h" ]]
    then
        echo -e " \n The command syntax is: findReplace oldString newString someStringToSearch\n"
        echo -e " someStringToSearch may be: <someString> or <someFile> or <Here-document> or <Here-string>"
        echo -e " Giving more than 4 parameter means the extras will be ignored, except! :"
        echo -e " - if you provide -a on the end, then a 'Replace All' will occur."
        echo -e " - if you provide -w on the end and your searched string was a file, the file will be updated."
        echo -e " - or in combination, a -aw for 'Replace All' and write the update to file.\n"
        echo -e " If successful, the updated string will be returned.\n"
        echo -e " The oldString may be a pattern, but not regular expressions."
        echo -e " To use regular expressions, use regexFindReplace instead."
        echo -e " For Pattern Matching visit https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching \n"

    else
        echo -e "\n Error - missing arguments."
        eval "_findReplace _result --help"
    fi

}

function _regexFindReplace()        # bash perl -pe  StringClass (grep -P)
{
    # <SIGNATURE>: (0)_regexFindReplace (1)_result (2)oldString/pattern (3)newString (4)someStringToSearch (5?)options
    # <RETURN>   : (0)<T>String
    # <OPTIONS>  : (0) -hd (1) -a or -w or -aw.
    # <BACKEND>  : bash, StringClass, perl -pe

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local _return_regexFindReplace=""
    local -i doAll=$FALSE
    local -i writeFile=$FALSE
    local stringToBeSearched=""

    if [[ $# -ge 4 ]] || [[ $# -eq 3 && ${#htmlLines[@]} -gt 0 ]]
    then
        
        # START - determine what the searched string will be
        if [[ $# -ge 4 ]] && [[ -f $4  ]]
        then
                #stringToBeSearched="$(sed -rn 's/.*/&/p' $4)"
                stringToBeSearched="$(< $4)"
        
        elif [[ $# -ge 4 ]]
        then
                stringToBeSearched="$4"
        
        elif [[ $# -eq 3 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
        then
                stringToBeSearched="${htmlLines[@]}"
        fi
        # END of searchedString

        # START - set the booleans for the optionals
        if [[ ! -z ${5:-} ]] && [[ $(_sc regexStringFind '([-]w*[a]{1,}w*\b)' ${5:-}) -gt 0 ]]
        then
            doAll=$TRUE
        fi

        if [[ ! -z ${5:-} ]] && [[ $(_sc regexStringFind '([-]a*[w]{1,}a*\b)' ${5:-}) -gt 0 ]] && [[ -f $4  ]]
        then
            writeFile=$TRUE
        fi
        # END setting the booleans

        #elif [[ ! -z ${5:-} ]] && [[ ${5:-} == "-w" ]] && [[ -f $4  ]]
        #then
        #    writeFile=$TRUE
        #
        #elif [[ ! -z ${5:-} ]] && [[ ${5:-} == "-aw" ]] && [[ -f $4  ]]
        #then
        #    doAll=$TRUE && writeFile=$TRUE
        #fi
        # END setting the booleans

        thePattern="${2:-}"
        newString="${3:-}"

        if [[ $doAll == $FALSE ]]
        then
            _return_regexFindReplace=`perl -pe s/"$thePattern"/"$newString"/ <<< "$stringToBeSearched"` || _return_regexFindReplace=""  # once
        else
            _return_regexFindReplace=`perl -pe s/"$thePattern"/"$newString"/g <<< "$stringToBeSearched"` || _return_regexFindReplace=""  # all
        fi

        if [[ $writeFile == $TRUE ]]
        then
            echo "$_return_regexFindReplace">$4
        fi

        eval "$1=\${_return_regexFindReplace}"

    # START - echo out the Help section
    elif [[ $# -eq 1 || "${2:-}" == "-?" || "${2:-}" == "--help" || "${2:-}" == "-h" ]]
    then
        echo -e " \n The command syntax is: findReplace oldString newString someStringToSearch\n"
        echo -e " someStringToSearch may be: <someString> or <someFile> or <Here-document> or <Here-string>"
        echo -e " Giving more than 4 parameter means the extras will be ignored, except! :"
        echo -e " - if you provide -a on the end, then a 'Replace All' will occur."
        echo -e " - if you provide -w on the end and your searched string was a file, the file will be updated."
        echo -e " - or in combination, a -aw for 'Replace All' and write the update to file.\n"
        echo -e " If successful, the updated string will be returned.\n"
        echo -e " regexFindReplace is PCRE compliant with its regular expressions. \n"

    else
        echo -e "\n Error - missing arguments."
        eval "_regexFindReplace _result --help"
    fi
    # END of help section

}

function _subString()               # bash                      # alias mid
{
    # <SIGNATURE>: (0)_subString (1)_result (2)someStringToSearch (3)offset (4)length
    # <RETURN>   : (0)<T>String
    # <OPTIONS>  : (0) -hd (1) -nl
    # <BACKEND>  : bash

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local _return_subString=0
    local -i noLength=$FALSE

    if [[ $# -ge 4 ]] || [[ $# -eq 3 && ${#htmlLines[@]} -gt 0 ]]
    then

        if [[ $# -eq 3 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
        then
                stringToBeSearched="${htmlLines[@]}"
        
        elif [[ $# -ge 4 ]] && [[ -f ${2:-}  ]]
        then
                stringToBeSearched="$(< ${2:-})"
        
        elif [[ $# -ge 4 ]]
        then
                stringToBeSearched="${2:-}"
        
        fi

        if [[ $# -eq 4 ]] && [[ ${4:-} == "-nl" ]]
        then
            noLength=$TRUE
        fi

        local -i theOffset=${3:-1}
        local theLength="${4:-}"

        theOffset="$(( theOffset - 1 ))"

        if [[ $noLength == $FALSE ]]
        then
            _return_subString="${stringToBeSearched:${theOffset}:${theLength}}"
        else
            _return_subString="${stringToBeSearched:${theOffset}}"
        fi

        eval "$1=\${_return_subString}"

    elif [[ $# -eq 1 || ${2:-} == "-?" || ${2:-} == "--help" || ${2:-} == "-h" ]]
    then
        echo -e "\n Extract and return a subString from within a larger piece of text or file. \n"
        echo -e " ${GREEN}subString someStringToSearch   offset length${NC}"
        echo -e " ${GREEN}subString someFileToSearch.txt offset length${NC}\n"
        echo -e " offset & length need to be whole +/- numbers eg. integers"
        echo -e " offset means: the position X number characters from the start of 'someStringToSearch'. \n"
        echo -e " It's ok to substitute '-nl' as a length to indicate 'no length', in which case,"
        echo -e " the rest of 'someStringToSearch' is returned, starting from offset. \n"
        echo -e " ${GREEN}subString FreddoFrogIsYummyChocolate 12 5    will return 'Yummy'"
        echo -e " subString FreddoFrogIsYummyChocolate 12 -nl  will return 'YummyChocolate'"
        echo -e " subString FreddoFrogIsYummyChocolate 12 -4   will return 'YummyChoco'${NC} \n"
        echo -e " A negative length means: come from the back of 'someStringToSearch', unlike"
        echo -e " a positive length, which means come forward from the offset position. \n"
        echo -e " See https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion \n" 
        echo -e " Giving more than 3 parameter means the extras will be ignored. \n"
        echo -e " -hd and Heredocs/Herestrings are valid as input eg. :\n"
        echo -e " -   ${GREEN}subString -hd 346 -7${NC}  or  ${GREEN}subString 421 5 -hd${NC}  or  "
        echo -e " -   ${GREEN}subString 76 2 <<EOF${NC}  or  ${GREEN}subString 88 12 <<<someString${NC} \n"

    else
        echo -e "\n ${RED}Error - missing arguments.${NC}"
        eval "_subString _result --help"
    fi
 
}

function _trim()                    # bash
{
    # <SIGNATURE>: (0)_trim (1)_result (2)someStringToTrim
    # <RETURN>   : (0)<T>String
    # <OPTIONS>  : (0) -hd
    # <BACKEND>  : bash

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local var="$2"
    #local _return_trim

    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    
    printf -v _return_trim '%s' "$var"
    eval "$1=\${_return_trim}"

}

function _lTrim()                   # bash
{
    # <SIGNATURE>: (0)_Ltrim (1)_result (2)someStringToTrim
    # <RETURN>   : (0)<T>String
    # <OPTIONS>  : (0) -hd
    # <BACKEND>  : bash

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local var="$2"
    #local _return_trim

    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    
    printf -v _return_trim '%s' "$var"
    eval "$1=\${_return_trim}"

}

function _rTrim()                   # bash
{
    # <SIGNATURE>: (0)_Rtrim (1)_result (2)someStringToTrim
    # <RETURN>   : (0)<T>String
    # <OPTIONS>  : (0) -hd
    # <BACKEND>  : bash

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local var="$2"
    local _return_trim

    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    
    printf -v _return_trim '%s' "$var"
    eval "$1=\${_return_trim}"

}

function _wsTrim()                  # StringClass (perl -pe)
{
    # <SIGNATURE>: (0)_wsTrim (1)_result (2)someString (3?)
    # <RETURN>   : (0)<T>String
    # <OPTIONS>  : (0) -hd (1) -s
    # <BACKEND>  : StringClass

    # small pre-processor to remove '-hd' from the argument list.
    local -i n=0
    for arg in $@
    do
        let "n+=1"
        if [[ $arg == "-hd" ]]
        then
            set -- "${@:1:n-1}" "${@:n+1}" # remove n'th positional argument - stackoverflow.com/a/23656370
        fi
    done

    # main part of the function

    local _return_wsTrim=""
    local _duplicateWSPattern='\s{2,}'            # these are single quoted,
    local _fullStops='\b\s+[.]'                  # to stop bash from interpreting
    local -i doSingle=$FALSE

    if [[ $# -ge 2 ]] || [[ $# -eq 1 && ${#htmlLines[@]} -gt 0 ]]
    then

        # START - determine what the searched string will be
        if [[ $# -ge 2 ]] && [[ -f $2  ]]
        then
                stringToBeSearched="$(< $2)"
        
        elif [[ $# -ge 2 ]]
        then
                stringToBeSearched="$2"
        
        elif [[ $# -eq 1 ]] && [[ ${#htmlLines[@]} -gt 0 ]]
        then
                stringToBeSearched="${htmlLines[@]}"
        fi
        # END of searchedString

        # START - set the booleans for the optionals
        if [[ ! -z ${3:-} ]] && [[ $(_sc regexStringFind '([-][s]{1,}\b)' ${3:-}) -gt 0 || $(_sc regexStringFind '([-][f]{1,}\b)' ${3:-}) -gt 0 ]]
        then
            doSingle=$TRUE
        fi
        # END setting the booleans

        _return_wsTrim="$stringToBeSearched"

        if [[ $doSingle == $FALSE ]]
        then
            _regexFindReplace _return_Temp   "$_duplicateWSPattern" ' ' "$stringToBeSearched" "-a"  # all
            _regexFindReplace _return_wsTrim  $_fullStops           '.' "$_return_Temp"       "-a"  # all

        else
            _regexFindReplace _return_wsTrim "$_duplicateWSPattern" " " "$stringToBeSearched"       # first/single
        fi        
    
        eval "$1=\${_return_wsTrim}"


    # START - echo out the Help section
    elif [[ $# -eq 1 || "${2:-}" == "-?" || "${2:-}" == "--help" || "${2:-}" == "-h" ]]
    then
        echo -e " \n The command syntax is: wsTrim someString\n"
        echo -e " someString may be: <someString> or <someFile> or <Here-document> or <Here-string>"
        echo -e " The default behaviour is to replace all occurrences."
        echo -e " Giving more than 2 parameter means the extras will be ignored, except! :"
        echo -e " - if you provide -s on the end, then only the first matching instance will occur."
        echo -e " If successful, the updated string will be returned.\n"
        echo -e " wsTrim is PCRE compliant with its regular expressions. \n"

    else
        echo -e "\n Error - missing arguments."
        eval "_wsTrim _result --help"
    fi
    # END of help section


}


#--------------------------------------------------------
# The Strings pseudo-class of string functions
#--------------------------------------------------------
#
StringClass()
(
    showUsage()
    (
        declare APIs=""
        echo -e "\n The following is a list of all the functions available in this script module.\n"
        
        APIs="$(declare -F)"
        APIs="${APIs//declare -f/.\/StringFunctions}"
        
        for apiName in "${APIs[@]}"
        do
            echo "$apiName"
        done
        echo -e "\n All Here Document, Here-doc or Heredoc style input must end with a plain 'EOF' eg. EOF"
        echo -e " Heredoc style input can be forced with the '-hd' switch as a parameter, terminated with EOF\n"
        echo -e " Functions with leading _underscores are the true APIs. They can be called directly from"
        echo -e " other scripts when 'sourced'. Note! the APIs expect to be passed a variable that will"
        echo -e " become the return result. The APIs do NOT echo their output.\n"
        echo -e " Conversely, the corresponding function names without leading _underscores can be called"
        echo -e " from the command-line and will echo their output.\n"
        echo -e " StringClass is the main function and has shorter pseudonyms for brevity, and they are:"
        echo -e " \tSC sc _SC _sc \n"
        echo -e " This is really only relevant when embedding one function call inside another eg.\n"
        echo -e '     source ./StringFunctions'
        echo -e '     declare chocolate="Caramel Koala"'
        echo -e '     StringClass stringLength "$chocolate"'
        echo -e '     SC subString "$chocolate" 1 $(( $(_sc len "$chocolate") - 2 ))"'
        echo -e "\n This example prints:\n\n \t13 \n \tCaramel Koa" 
        echo -e "\n Note: StringFunctions counts collections starting at 1, not 0. If you have a string of"
        echo -e " characters > 0, then position 1 is occupied by the first character."
        echo ""

    ) >&2
    
    isValidArg()
    (
        test "$(type -t "$1")" = "function"
    )

    countLines()
    (
        local _result
        _countLines _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    countWords()
    (
        local _result
        _countWords _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    stringLength()
    (
        local _result
        _stringLength _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    len() # Pseudonym / Alias for stringLength
    (
        local _result
        _stringLength _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    regexStringFind()
    (
        local _result
        _regexStringFind _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    inStr() # Pseudonym / Alias for regexStringFind
    (
        local _result
        _regexStringFind _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    regexStringFind2()
    (
        local -A _resultArray=()
        _regexStringFind2 _resultArray "$@"
        [ ! -z "${_resultArray:-()}" ] && echo -e "${#_resultArray[@]}\n"
    )

    regexFind()
    (:;)

    findReplace()
    (
        local _result
        _findReplace _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    regexFindReplace()
    (
        local _result
        _regexFindReplace _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    subString()
    (
        local _result
        _subString _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    mid() # Pseudonym / Alias for subString
    (
        local _result
        _subString _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    regexSubstr()
    (:;)

    trim()
    (
        local _result
        _trim _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    lTrim()
    (
        local _result
        _lTrim _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    rTrim()
    (
        local _result
        _rTrim _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    wsTrim()
    (
        local _result
        _wsTrim _result "$@"
        [ ! -z "${_result:-}" ] && echo -e "$_result"
    )

    #isNumber(){ printf %f "$1" &>/dev/null && echo "true" || echo "false" }
    #isArray() { declare -p test1 2>/dev/null | grep -q '^declare \-[aA]' && echo "test1 is an array type" || echo "test1 is not an array type" }

    #--------------------------------
    # Parameter check for StringClass
    #--------------------------------
    #
    if [[ $# -gt 0 ]]
    then

        if isValidArg $@
        then
            "$@"
        else
            showUsage
        fi

    else
        showUsage
    fi
)

#--------------------------------------------------------
# Pseudonyms / Aliases for StringClass
#--------------------------------------------------------
#
SC()(StringClass "$@")
sc()(StringClass "$@")
_SC()(StringClass "$@")
_sc()(StringClass "$@")

#--------------------------------------------------------
# Process the "real" command line that called this script
#--------------------------------------------------------
#
if [[ -t 0 ]]      # input comes only from the string on the command line - no redirection.
then

    #if   [[ $# -eq 0 ]]
    #then
    #    #usage
    #    #StringClass showUsage
    #    echo
    #
    #elif [[ $# -gt 0 ]]
    if [[ $# -gt 0 ]]
    then

        if [[ ${1:0:1} == "-" ]] && [[ ${1:1:1} =~ [[:graph:]] ]]
        then
            #echo "found invalid option"
            StringClass showUsage
            exit
        fi

        theArgs=("$@")

        for arg in "${theArgs[@]}"
        do
            if [[ $arg == "-hd" ]]
            then
                readInput # read more input into the htmlLines array
            fi
        done

    fi

else               # input comes from redirection.

    theArgs=("$@")
    readInput  # read more input into the htmlLines array

fi

#----------------------------------------------------------
# Then, send all known command line data into StringClass()
#----------------------------------------------------------
#
if [[ ${#theArgs[@]} -gt 0 ]]
then

    #echo -e "${theArgs[@]}"
    StringClass "${theArgs[@]}"

fi
